def repeating_dec_sol(numerator, denominator):
    negative = False
    if denominator == 0:
        return 'Undefined'
    if numerator == 0:
        return '0'
    if numerator * denominator < 0:
        negative = True
    if numerator % denominator == 0:
        return str(numerator / denominator)

    num = abs(numerator)
    den = abs(denominator)

    result = ""
    result += str(num // den)
    result += "."

    quotient_num = []
    while num:
    	# In case the remainder is equal to zero, there are no repeating
        # decimals. Therefore, we don't need to add any parenthesis and we can
        # break the while loop and return the result.
        remainder = num % den
        if remainder == 0:
            for i in quotient_num:
                result += str(i[-1])
            break
        num = remainder*10
        quotient = num // den

		# If the new numerator and quotient are not already in the list, we
        # append them to the list.
        if [num, quotient] not in quotient_num:
            quotient_num.append([num, quotient])
        # If the new numerator and quotient are instead already in the list, we
        # break the execution and we prepare to return the final result.
        # We take track of the index position, in order to add the parenthesis
        # at the output in the right place.
        elif [num, quotient] in quotient_num:
            index = quotient_num.index([num, quotient])
            for i in quotient_num[:index]:
                result += str(i[-1])
            result += "("
            for i in quotient_num[index:]:
                result += str(i[-1])
            result += ")"
            break

        if negative:
            result = "-" + result

    return result

NUM, DEN = 1, 7
#print("The result of the fraction", NUM, "/", DEN, "is equal to: ",
       #repeating_dec_sol(NUM, DEN))

print((1/7).as_integer_ratio())



number = input('Input a decimal number with the repeating digits in between brackets: ')


def parse_input(input):
    repeating_number = input.split('(', 1)[1].split(')')[0]
    original_number = input.replace('(', '')
    original_number = original_number.replace(')', '')
    return (repeating_number, original_number)


def do_math(repeating_number, original_number):

    # does like thing idk forgot what i did

    multiplied_number = original_number
    decimal_thing = repeating_number
    multiplied_by = 1
    for _ in range(len(repeating_number)):
        multiplied_number = float(multiplied_number) * 10
        decimal_thing = float(decimal_thing) / 10
        multiplied_by *= 10

    # not at all useless

    multiplied_number += decimal_thing

    # uh do the minus thing

    multiplied_number -= decimal_thing
    multiplied_by -= 1

    # fractions woo

    top_thingy = int(multiplied_number)
    bottom_thingy = int(multiplied_by)

    is_divisible = False
    is_divisible_by = 1

    for i in range(min(abs(top_thingy), abs(bottom_thingy)), 1, -1):
        if top_thingy % i == 0 and bottom_thingy % i == 0:
            is_divisible_by = i
            break

    top_thingy /= is_divisible_by
    bottom_thingy /= is_divisible_by

    return (top_thingy, bottom_thingy)


print(do_math(parse_input(number)[0], parse_input(number)[1]))





    while continue_divisions == True:
        for i in range(2, 10):
            if top_thingy % i == 0 and bottom_thingy % i == 0:
                top_thingy /= i
                bottom_thingy /= i
                is_divisible_by = i
                if current_division == 0:
                    current_division = i
                    print(current_division)
                else:
                    current_division *= i
                    print(current_division)
        if current_division == previous_division :
            continue_divisions = False
        else:
            previous_division = current_division
